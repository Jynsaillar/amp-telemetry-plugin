<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <!-- In production, instead of referencing 'latest', always use a specific version of the AMP player, as mentioned here: -->
    <!-- https://docs.microsoft.com/en-us/azure/media-services/azure-media-player/azure-media-player-full-setup -->
    <link href="//amp.azure.net/libs/amp/2.3.10/skins/amp-default/azuremediaplayer.min.css" rel="stylesheet">
    <script src="//amp.azure.net/libs/amp/2.3.10/azuremediaplayer.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.1.min.js"
        integrity="sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=" crossorigin="anonymous"></script>
    <script>
        (function () {
            amp.plugin('telemetry', function (options) {

                var player = this

                var init = function () {
                    console.log("plugin telemetry initialized with player ", player)
                }

                // initialize the plugin
                init();

                // Holds the telemetry frontend data required by the QoE test.
                var telemetryContainerObject = {
                    videoFrameWidth: 0,
                    videoFrameHeight: 0,
                    bitrateSelected: 0,
                    bitratesAvailable: [],
                    bitrateSwitches: 0,
                    shortBufferingEvents: 0,
                    longBufferingEvents: 0,
                    timeSpentBuffering: 0,
                }

                // Number of bitrate changes (counter).
                telemetryContainerObject.bitrateSwitches = 0;

                // Player dimensions.
                var pWidth = 0;
                var pHeight = 0;

                // Fires when the download bitrate changes -> during player initialization/stream load, also when the user manually changes the bitrate.
                player.addEventListener(amp.eventName.downloadbitratechanged, function () {

                    console.log("Event fired: downloadbitratechanged");
                    telemetryContainerObject.bitrateSwitches++;
                    console.log(`Total number of bitrate changes so far: ${telemetryContainerObject.bitrateSwitches}`);

                    var currentDownloadBitrate = player.currentDownloadBitrate();
                    telemetryContainerObject.bitrateSelected = currentDownloadBitrate;
                    console.log(`Selected bitrate: ${currentDownloadBitrate}`);

                    // Null check active player stream.
                    var stream = player.currentVideoStreamList().streams ? player.currentVideoStreamList().streams[0] : undefined;
                    if (stream) {

                        var pWidth = player.width();
                        var pHeight = player.height();
                        telemetryContainerObject.videoFrameWidth = pWidth;
                        telemetryContainerObject.videoFrameHeight = pHeight;
                        console.log(`New player dimensions: ${pWidth}x${pHeight}`);

                        // Active stream track information.
                        var streamTracks = stream._commonStream._tracks;
                        var trackWidth = 0;
                        var trackHeight = 0;

                        for (i = 0; i < streamTracks.length; i++) {
                            telemetryContainerObject.bitratesAvailable.push(streamTracks[i]._bitrate);
                            // Reduce nesting by checking for negated condition.
                            if (!(streamTracks[i]._bitrate == currentDownloadBitrate)) {
                                continue;
                            }

                            trackWidth = streamTracks[i]._width;
                            trackHeight = streamTracks[i]._height;
                            console.log(`Found matching bitrate: ${currentDownloadBitrate} with width ${trackWidth}, height ${trackHeight}`);

                            if (trackWidth < pWidth || trackHeight < pHeight) {
                                console.log(`[WARNING] HIGHEST_BITRATE_POSSIBLE is false; The selected bitrate is intended for a smaller player frame size!`);
                            }
                        }
                    }
                });

                var bufferingTracker = {
                    isBuffering: false,
                    timeSpentBufferingTotal: 0,
                    bufferingEventsTotal: 0,
                    shortBufferingEventsTotal: 0,
                    longBufferingEventsTotal: 0,
                    lastBufferingStartTimestamp: 0,
                    lastBufferingEndTimestamp: 0,
                    lastBufferingEventDurationMs: 0,
                    initialBuffer: true,
                    bufferingStarted: function () {
                        this.isBuffering = true;
                        this.bufferingEventsTotal++;
                        this.lastBufferingStartTimestamp = new Date().getTime();
                    },
                    bufferingEnded: function () {
                        this.isBuffering = false;
                        this.lastBufferingEndTimestamp = new Date().getTime();
                        this.lastBufferingEventDurationMs = Math.abs(this.lastBufferingEndTimestamp - this.lastBufferingStartTimestamp);
                        this.timeSpentBufferingTotal += this.lastBufferingEventDurationMs;
                        if (this.lastBufferingEventDurationMs > 500) {
                            // Buffering was longer than 500ms.
                            this.shortBufferingEventsTotal += 1;

                            if (this.lastBufferingEventDurationMs > 1000) {
                                // Buffering was longer than 1000ms = 1 second.
                                this.longBufferingEventsTotal += 1;
                            }
                        }
                        ajaxSendTelemetry(telemetryContainerObject);
                    },
                    // Not 100% sure if the waiting event fires once when the player loads initially, so this 
                    // preconfigures the bufferingTracker as if the waiting event had happened once already.
                    initialBuffering: function () {
                        this.initialBuffer = false;
                        this.bufferingEventsTotal++;
                        this.lastBufferingStartTimestamp = new Date().getTime();
                        this.bufferingEnded();
                    }
                    // TODO: Add reset function here, so that the time requirements can be satisfied
                };

                player.addEventListener(amp.eventName.waiting, function () {
                    // Buffering probably starts here.
                    console.log("waiting...");
                    if (!bufferingTracker.isBuffering) {
                        bufferingTracker.bufferingStarted();
                    }

                });
                player.addEventListener(amp.eventName.playing, function () {
                    // Buffering should end here, *if* the player was buffering before.
                    console.log("playing!");
                    if (bufferingTracker.initialBuffer == true) {
                        bufferingTracker.initialBuffering();
                    }
                    else {
                        if (bufferingTracker.isBuffering) {
                            bufferingTracker.bufferingEnded();
                        }
                    }
                    telemetryContainerObject.longBufferingEvents = bufferingTracker.longBufferingEventsTotal;
                    telemetryContainerObject.shortBufferingEvents = bufferingTracker.longBufferingEventsTotal;
                    console.log(`Time spent buffering so far during ${bufferingTracker.bufferingEventsTotal} buffering events: ${bufferingTracker.timeSpentBufferingTotal}ms`);
                    console.log(`Short buffering events: ${bufferingTracker.shortBufferingEventsTotal}`);
                    console.log(`Critical long buffering events: ${bufferingTracker.longBufferingEventsTotal}`);
                });

                // Sends the contents of the telemetryContainer off to the backend API (via GET parameters) and receives the API response as json (if successful).
                function ajaxSendTelemetry(telemetryContainer) {
                    const apiUrl = 'https://localhost:7140/telemetry';
                    $.ajax({
                        url: apiUrl,
                        data: telemetryContainer,
                        type: "GET",
                        success: function (result) {
                            console.log(result);
                        },
                        error: function (error) {
                            console.log(error);
                        }

                    });
                }
            });
        }).call(this);

    </script>
</head>

<body>

    <video id="vid1" class="azuremediaplayer amp-default-skin" width="640" height="400">
        <p class="amp-no-js">
            To view this video please enable JavaScript, and consider upgrading to a web browser that supports HTML5
            video
        </p>
    </video>
    <script>
        var myPlayer = amp('vid1', {
            /* Options */
            "nativeControlsForTouch": false,
            autoplay: true,
            controls: true,
            width: "640",
            height: "400",
            techOrder: ['AzureHtml5JS'],
            plugins: {
                /* load our telemetry plugin */
                telemetry: {
                    /* Options */
                }
            }
        }, function () {
            console.log('Good to go!');

        }
        );

        myPlayer.src([{
            src: "https://amssamples.streaming.mediaservices.windows.net/91492735-c523-432b-ba01-faba6c2206a2/AzureMediaServicesPromo.ism/manifest(format=mpd-time-csf)",
            type: "application/dash+xml"
        }]);
    </script>

</body>

</html>